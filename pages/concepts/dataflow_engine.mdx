# ReadySet Dataflow Engine

The heart of ReadySet is the dataflow engine. Given a prepared statement, the dataflow engine compiles 
that query into a dataflow graph that is responsible for executing that query. The roots of the graph are 
nodes that represent the application base tables (“base table nodes”). 

## Data Change Ingestion 
ReadySet monitors the primary database’s binlogs (log files that contain information about data modifications 
made as the result of users issuing inserts/updates/deletes) and replicates these data changes (“deltas”) to 
the base table nodes. The base table nodes serve as an entry point to the overall dataflow graph: once deltas 
enter the base tables nodes, they then propagate down through any outgoing edges connected to these nodes, passing 
through other children nodes until they finally hit the leaf nodes of the graph.

## Graph Composition 
There are two other node types in the graph: internal nodes and reader nodes. Internal nodes are associated with 
SQL operators (i.e. functions from relational algebra like joins, aggregates, projections, and filters). They each 
compute their associated function on incoming deltas, and maintain internal state representing the results of their 
function. Whenever their internal state changes (e.g. whenever they receive new deltas that cause their function 
output to change), these nodes emit new deltas that represent these changes, and send them down outgoing edges to 
any children nodes.

Queries can be decomposed into constituent SQL operations, and internal nodes are chained together in a way that 
represents this query. The resulting dataflow graphs look similar to traditional database query plans, but since 
they are materialized in memory, they are optimized in a different way. The leaf nodes of the graph, referred to as 
reader nodes, cache the final query results. Reader nodes can be replicated on arbitrary machines in the same region 
or in different ones.

As writes occur, the resulting data changes are immediately replicated to ReadySet. ReadySet incrementally updates the 
cached query results to reflect these changes. This automatic cache result repair mechanism replaces any developer-written 
cache eviction logic.

## Example Application: Hacker News
To illustrate these concepts, we will walk through an example of using ReadySet for a news forum application inspired 
by HackerNews.

### Schema 
```SQL
CREATE TABLE stories (id int, author text, title text, url text);
```
```SQL
CREATE TABLE votes (user int, story_id int);
```
### Query 
```SQL 
SELECT id, author, title, url, vcount
FROM stories
JOIN (SELECT story_id, COUNT(*) AS vcount 
            FROM votes GROUP BY story_id) 
AS VoteCount
ON VoteCount.story_id = stories.id WHERE stories.id = ?;
``` 
Let’s break this query down further: the VoteCount subquery counts all of the votes associated with each story, and 
returns them along with the story ID. From there, we join the VoteCount results with the stories table on story ID to 
combine all of the raw info about the story with its computed vote count. The results of the JOIN node then pass through 
the > filter on vcount. To then get the result of this query for a given story ID 4, you would instantiate it and replace 
the ? parameter with 4. We will refer to this parameter as the key.

### Caching Query Results with ReadySet 
Traditional databases would compute the results of this query from scratch every time it was issued. ReadySet takes a 
different approach and instead precomputes and incrementally maintains the results of this query for commonly read keys.

To accomplish this, ReadySet creates a streaming dataflow graph, as described in the previous section. Under the hood, the 
data flow graph would look as follows:

Next, we’ll take a look at what happens when the data changes. Let’s say that we add a record to the Votes table to reflect 
the fact that Justin voted for the story with ID 2. This update would first be applied to the Votes base table at the root 
of the graph, and then be propagated through the graph, updating all children nodes along that way. Figure 7 below shows the 
modified state at each node as the result of this write.